操作系统
操作系统基础
什么是操作系统?
1. 操作系统(Operating System，简称 OS)是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石;
2. 操作系统本质上是运行在计算机上的软件程序 ;
3. 操作系统为用户提供一个与系统交互的操作界面 ;
4. 操作系统分内核与外壳(我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序)。
什么是系统调用？
介绍系统调用之前，我们先来了解一下用户态和系统态。
根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别:
1. 用户态(user mode) : 用户态运行的进程或可以直接读取用户程序的数据。
2. 系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。说了用户态和系统态之后，那么什么是系统调用呢?我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢?那就需要系统调用了!也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作(如文件管理、进程控制、内 存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。
这些系统调用按功能大致可分为如下几类:
   设备管理。完成设备的请求或释放，以及设备启动等功能。
   文件管理。完成文件的读、写、创建及删除等功能。
   进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。
   进程通信。完成进程之间的消息传递或信号传递等功能。
   内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。
进程和线程
进程和线程区别：
线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，是资源分配的基本单位。而各线程则不一定，因为同一进程中的线程极有可能会相互影响，是系统调度的基本单位。线程执行开销小，但不利于资源的管理和保护;而进程正相反。
进程的状态：
创建状态(new) :进程正在被创建，尚未到就绪状态。
就绪状态(ready) :进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源， 一旦得到处理器资源(处理器分配的时间片)即可运行。
运行状态(running) :进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状 态)。
阻塞状态(waiting) :又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用 或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
结束状态(terminated) :进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运 行。
进程间的通信方式：
（https://www.jianshu.com/p/c1015f5ffa74）
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信
- 同一个机器：
  - 管道
    - 匿名管道：具有亲缘关系的父子进程之间或兄弟进程之间的通信；
    - 有名管道：以磁盘文件形式存在，本机任意两个进程通信；
  - 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
  - 信号量：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在 于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
  - 消息队列：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道(无名管道:只存在 于内存中的文件;命名管道:存在于实际的磁盘介质或者文件系统)不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按 消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式 字 节流以及缓冲区大小受限等缺。
  - 共享内存：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对 方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可 以说这是最有用的进程间通信方式。
- 不同机器：
  - 套接字：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简 单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。
线程的同步方式：
线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使 用冲突。操作系统一般有下面三种线程同步的方式:
1. 互斥量(Mutex):采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为 互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. 信号量(Semphares) :它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资 源的最大线程数量
3. 事件(Event) :Wait/Notify:通过通知操作的方式来保持多线程同步，还可以方便的实现多线程 优先级的比较操

进程的调度算法：
批处理系统调度：
- 先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使 它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- 短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源， 使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
交互式系统调度：
- 时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又 称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的 时间。
- 多级反馈队列调度算法 :前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的 调度算法，仅照顾了短进程而忽略了⻓进程 。多级反馈队列调度算法既能使高优先级的作业得 到响应又能使短作业(进程)迅速完成。，因而它是目前被公认的一种较好的进程调度算法， UNIX 操作系统采取的便是这种调度算法。
- 优先级调度 : 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同 优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先 级。
内存管理
操作系统的内存管理主要是做什么?
操作系统的内存管理主要负责内存的分配与回收(malloc 函数:申请内存，free 函数:释 放内存)，另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。

常见的内存管理机制：
简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配 一个连续的内存空间，常⻅的如 块式管理 。同样地，非连续分配管理方式允许一个程序使用的内存分 布在离散或者说不相邻的内存中，常⻅的如⻚式管理 和 段式管理。
1. 块式管理 : 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块 中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需 要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. ⻚式管理 :把主存分为大小相等且固定的一⻚一⻚的形式，⻚较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。⻚式管理通过⻚表对应逻辑地址和物理地址。
3. 段式管理 : ⻚式管理虽然提高了内存利用率，但是⻚式管理其中的⻚实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一⻚的空间小很多 。但是，最重要的是段 是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. 段⻚式管理：分段+分页=段页式管理，段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若干段，每个段又分成若干⻚， 也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。
5. 分页和分段相同点：
  1. 分⻚机制和分段机制都是为了提高内存利用率，较少内存碎片。
  2. ⻚和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个⻚和段中的内 存是连续的。
6. 分页和分段区别：
  1. 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。
  2. 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
  3. 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。
  4. 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
  5. 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的

快表和多级页表
在分⻚内存管理中，很重要的两点是:
1. 虚拟地址到物理地址的转换要快。
2. 解决虚拟地址空间大，⻚表也会很大的问题。
快表
为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表方案 基础之上引入了 快表 来加速虚拟地 址到物理地址的转换。我们可以把块表理解为一种特殊的高速缓冲存储器(Cache)，其中的内容是⻚ 表的一部分或者全部内容。作为⻚表的 Cache，它的作用与⻚表相似，但是提高了访问速率。由于采用 ⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储 器，一次主存，这样可加速查找并提高指令执行速度。
使用快表之后的地址转换流程是这样的:
1. 根据虚拟地址中的⻚号查快表;
2. 如果该⻚在快表中，直接从快表中读取相应的物理地址;
3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射
4. 表项添加到快表中;
5. 当快表填满后，又要登记新⻚时，就按照一定的淘汰策略淘汰掉快表中的一个⻚。
看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存(比如 Redis)很像，的确是这 样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中 找到它们的影子。
多级⻚表
引入多级⻚表的主要目的是为了避免把全部⻚表一直放在内存中占用过多空间，特别是那些根本就不需
要的⻚表就不需要保留在内存中。多级⻚表属于时间换空间的典型场景，具体可以查看下面这篇文章
多级⻚表如何节约内存:https://www.polarxiong.com/archives/多级⻚表如何节约内存.html 总结
为了提高内存的空间性能，提出了多级⻚表的概念;但是提到空间性能是以浪费时间性能为基础的，因 此为了补充损失的时间性能，提出了快表(即 TLB)的概念。 不论是快表还是多级⻚表实际上都利用 到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。

虚拟地址和物理地址
我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储 的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决 定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是 内存单元真正的地址。

为什么有虚拟地址：
先从没有虚拟地址空间的时候说起吧!没有虚拟地址空间的时候，程序都是直接访问和操作的都是物理内存 。但是这样有什么问题呢?
1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易(有意或者无意)破坏操作系 统，造成操作系统崩溃。
2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么 呢?举个简单的例子:微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序 就会崩溃。
总结来说:如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同
时运行多个程序造成困难。
通过虚拟地址访问内存有以下优势:
- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
-  程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小 时，内存管理器会将物理内存⻚(通常大小为 4 KB)保存到磁盘文件。数据或代码⻚会根据需 要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用 的物理内存。
虚拟内存
什么是虚拟内存
很多时候我们使用点开了很 多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以 这样呢? 正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的 可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了 一种自己在独享主存的错觉(每个进程拥有一片连续完整的内存空间)。这样会更加有效地管理内存并 减少出错。
虚拟内存是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚 拟内存只是“使用硬盘空间来扩展内存“的技术。虚拟内存的重要意义是它定义了一个连续的虚拟地址空 间，并且 把内存扩展到硬盘空间。

局部性原理
局部性原理表现在以下两个方面:
1. 时间局部性 :如果程序中的某条指令一旦执行，不久以后该指令可能再次执行;如果某数据被 访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着 大量的循环操作。
2. 空间局部性 :一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即 程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、 顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。
时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实 现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存 技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。

虚拟存储器
基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动 程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实 际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入 内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间 存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——虚拟存储 器。
实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，⻚的调入调出花费的 时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就 是空间换时间。

虚拟内存的技术实现
虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。 虚拟内存的实现有以下三种 方式:
1. 请求分⻚存储管理 :建立在分⻚管理之上，为了支持虚拟存储器功能而增加了请求调⻚功能和 ⻚面置换功能。请求分⻚是目前最常用的一种实现虚拟存储器的方法。请求分⻚存储管理系统 中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现 要访问的⻚面不在内存，则由处理器通知操作系统按照对应的⻚面置换算法将相应的⻚面调入到 主存，同时操作系统也可以将暂时不用的⻚面置换到外存中。
2. 请求分段存储管理 :建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分 段储存管理方式就如同请求分⻚储存管理方式一样，在作业开始运行之前，仅装入当前要执行的 部分段即可运行;在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段; 当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入 新的段。
3. 请求段⻚式存储管理
这里多说一下?很多人容易搞混请求分⻚与分⻚存储管理，两者有何不同呢?
请求分⻚存储管理建立在分⻚管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分⻚存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。
它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分⻚存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分⻚存储管理可以提供虚存，而分⻚存储管理却不能提供虚存。
不管是上面那种实现方式，我们一般都需要:
4. 一定容量的内存和外存:在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留 在外存，然后程序就可以执行了;
5. 缺⻚中断:如果需执行的指令或访问的数据尚未在内存(称为缺⻚或缺段)，则由处理器通知操 作系统将相应的⻚面或段调入到内存，然后继续执行程序;
6. 虚拟地址空间 :逻辑地址到物理地址的变换。

页面置换算法
当发生缺⻚中断时，如果当前内存中并没有空闲的⻚面，操作系统就必须在内存选择一个⻚面将其移出内存，以便为即将调入的⻚面让出空间。用来选择淘汰哪一⻚的规则叫做⻚面置换算法，我们可以把⻚面置换算法看成是淘汰⻚面的规则。
OPT ⻚面置换算法(最佳⻚面置换算法) :最佳(Optimal, OPT)置换算法所选择的被淘汰⻚面 将是以后永不使用的，或者是在最⻓时间内不再被访问的⻚面,这样可以保证获得最低的缺⻚ 率。但由于人们目前无法预知进程在内存下的若千⻚面中哪个是未来最⻓时间内不再被访问的， 因而该算法无法实现。一般作为衡量其他置换算法的方法。
FIFO(First In First Out) ⻚面置换算法(先进先出⻚面置换算法) : 总是淘汰最先进入内 存的⻚面，即选择在内存中驻留时间最久的⻚面进行淘汰。
LRU (Least Currently Used)⻚面置换算法(最近最久未使用⻚面置换算法) :LRU算法赋予 每个⻚面一个访问字段，用来记录一个⻚面自上次被访问以来所经历的时间 T，当须淘汰一个⻚ 面时，选择现有⻚面中其 T 值最大的，即最近最久未使用的⻚面予以淘汰。
LFU (Least Frequently Used)⻚面置换算法(最少使用⻚面置换算法) : 该置换算法选择在 之前时期使用最少的⻚面作为淘汰⻚。
